{
  "name": "Enhanced Voice Intake - Part 3: Compliance & Scope",
  "nodes": [
    {
      "name": "CSLB Compliance Check",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "// Function Node: CSLB Compliance Checker\n// Input: $json.extractedData (extracted project data)\n// Output: Compliance status, warnings, and recommendations\n\nconst contractData = $json.extractedData || $json;\nconst callSid = contractData.callSid || $json.CallSid;\n\n// CSLB ¬ß7159 Home Improvement Contract Requirements\nconst cslbRequirements = {\n  // Required contract elements\n  requiredElements: {\n    contractorInfo: {\n      name: 'Contractor Information',\n      required: true,\n      fields: ['contractorName', 'contractorAddress', 'licenseNumber', 'phoneNumber']\n    },\n    clientInfo: {\n      name: 'Client Information', \n      required: true,\n      fields: ['clientName', 'clientAddress', 'phoneNumber']\n    },\n    projectDetails: {\n      name: 'Project Details',\n      required: true,\n      fields: ['projectAddress', 'scopeOfWork', 'projectType']\n    },\n    financialTerms: {\n      name: 'Financial Terms',\n      required: true,\n      fields: ['contractPrice', 'paymentTerms', 'paymentSchedule']\n    },\n    timeline: {\n      name: 'Project Timeline',\n      required: true,\n      fields: ['startDate', 'completionDate']\n    },\n    materials: {\n      name: 'Materials Information',\n      required: true,\n      fields: ['materialsProvidedBy', 'materialsDescription']\n    },\n    permits: {\n      name: 'Permits and Licenses',\n      required: true,\n      fields: ['permitsRequired', 'whoObtainsPermits']\n    },\n    warranties: {\n      name: 'Warranties',\n      required: true,\n      fields: ['warrantyPeriod', 'warrantyCoverage']\n    }\n  },\n  \n  // Payment structure requirements\n  paymentRequirements: {\n    maxUpfront: 0.10, // Maximum 10% upfront for contracts > $1,000\n    progressPayments: true,\n    finalPayment: 'upon completion and acceptance',\n    lienRights: true\n  },\n  \n  // Prohibited terms\n  prohibitedTerms: [\n    'waiver of lien rights',\n    'unconditional lien waiver',\n    'pay when paid clauses',\n    'no damages for delay',\n    'unlimited indemnification'\n  ]\n};\n\n// Validation functions\nconst validators = {\n  // Check if all required fields are present\n  checkRequiredFields: (data) => {\n    const missing = [];\n    const warnings = [];\n    \n    Object.entries(cslbRequirements.requiredElements).forEach(([key, requirement]) => {\n      const hasRequiredFields = requirement.fields.some(field => data[field]);\n      \n      if (requirement.required && !hasRequiredFields) {\n        missing.push(requirement.name);\n      } else if (requirement.required && hasRequiredFields) {\n        // Check for partial completion\n        const completedFields = requirement.fields.filter(field => data[field]);\n        if (completedFields.length < requirement.fields.length) {\n          warnings.push(`‚ö†Ô∏è ${requirement.name}: Incomplete (${completedFields.length}/${requirement.fields.length} fields)`);\n        }\n      }\n    });\n    \n    return { missing, warnings };\n  },\n  \n  // Validate payment structure\n  validatePaymentStructure: (paymentTerms) => {\n    const warnings = [];\n    \n    if (!paymentTerms) return warnings;\n    \n    const terms = paymentTerms.toLowerCase();\n    \n    // Check for excessive upfront payment\n    const upfrontMatch = terms.match(/(\\d+)%\\s*upfront/);\n    if (upfrontMatch) {\n      const upfrontPercent = parseInt(upfrontMatch[1]);\n      if (upfrontPercent > 10) {\n        warnings.push(`‚ö†Ô∏è Upfront payment (${upfrontPercent}%) exceeds CSLB maximum (10%)`);\n      }\n    }\n    \n    // Check for prohibited terms\n    cslbRequirements.prohibitedTerms.forEach(term => {\n      if (terms.includes(term)) {\n        warnings.push(`üö´ Prohibited term detected: \"${term}\"`);\n      }\n    });\n    \n    // Check for progress payments\n    if (!terms.includes('progress') && !terms.includes('milestone') && !terms.includes('completion')) {\n      warnings.push('‚ö†Ô∏è Payment structure should include progress payments or completion-based terms');\n    }\n    \n    return warnings;\n  },\n  \n  // Validate project scope\n  validateProjectScope: (scope, projectType) => {\n    const warnings = [];\n    \n    if (!scope || scope.length < 10) {\n      warnings.push('‚ö†Ô∏è Project scope is too brief - CSLB requires detailed description');\n    }\n    \n    if (projectType && scope) {\n      // Check for scope-type alignment\n      const scopeLower = scope.toLowerCase();\n      const typeLower = projectType.toLowerCase();\n      \n      if (!scopeLower.includes(typeLower) && !scopeLower.includes('renovation') && !scopeLower.includes('construction')) {\n        warnings.push('‚ö†Ô∏è Project scope should clearly describe the type of work');\n      }\n    }\n    \n    return warnings;\n  },\n  \n  // Validate timeline\n  validateTimeline: (startDate, endDate) => {\n    const warnings = [];\n    \n    if (!startDate) {\n      warnings.push('‚ö†Ô∏è Start date is required for CSLB compliance');\n    }\n    \n    if (!endDate) {\n      warnings.push('‚ö†Ô∏è Completion date should be specified');\n    } else if (startDate && endDate) {\n      // Check if end date is after start date\n      const start = new Date(startDate);\n      const end = new Date(endDate);\n      \n      if (end <= start) {\n        warnings.push('‚ö†Ô∏è Completion date should be after start date');\n      }\n    }\n    \n    return warnings;\n  },\n  \n  // Validate license information\n  validateLicense: (licenseNumber, contractorName) => {\n    const warnings = [];\n    \n    if (!licenseNumber && contractorName) {\n      warnings.push('‚ö†Ô∏è Contractor license number is required for CSLB compliance');\n    }\n    \n    if (licenseNumber) {\n      // Basic CA license format validation\n      const caLicensePattern = /^[A-Z]\\d{8}$/;\n      if (!caLicensePattern.test(licenseNumber)) {\n        warnings.push('‚ö†Ô∏è License number format appears invalid (should be A12345678)');\n      }\n    }\n    \n    return warnings;\n  }\n};\n\n// Main compliance check function\nconst runComplianceCheck = () => {\n  const startTime = Date.now();\n  \n  try {\n    // Run all validations\n    const requiredCheck = validators.checkRequiredFields(contractData);\n    const paymentWarnings = validators.validatePaymentStructure(contractData.payment_terms || contractData.paymentTerms);\n    const scopeWarnings = validators.validateProjectScope(contractData.scope_of_work || contractData.scopeOfWork, contractData.project_type || contractData.projectType);\n    const timelineWarnings = validators.validateTimeline(contractData.start_date || contractData.startDate, contractData.end_date || contractData.endDate);\n    const licenseWarnings = validators.validateLicense(contractData.license_number || contractData.licenseNumber, contractData.business_name || contractData.businessName);\n    \n    // Combine all warnings\n    const allWarnings = [\n      ...requiredCheck.warnings,\n      ...paymentWarnings,\n      ...scopeWarnings,\n      ...timelineWarnings,\n      ...licenseWarnings\n    ];\n    \n    // Determine compliance status\n    const isCompliant = requiredCheck.missing.length === 0 && allWarnings.length === 0;\n    const needsReview = requiredCheck.missing.length === 0 && allWarnings.length > 0;\n    const nonCompliant = requiredCheck.missing.length > 0;\n    \n    let complianceStatus;\n    if (isCompliant) {\n      complianceStatus = 'COMPLIANT';\n    } else if (needsReview) {\n      complianceStatus = 'REVIEW_REQUIRED';\n    } else {\n      complianceStatus = 'NON_COMPLIANT';\n    }\n    \n    // Generate recommendations\n    const recommendations = [];\n    \n    if (requiredCheck.missing.length > 0) {\n      recommendations.push(`Add missing required elements: ${requiredCheck.missing.join(', ')}`);\n    }\n    \n    if (allWarnings.length > 0) {\n      recommendations.push('Review and address compliance warnings');\n    }\n    \n    if (!contractData.license_number && !contractData.licenseNumber) {\n      recommendations.push('Include contractor license number');\n    }\n    \n    if (!contractData.end_date && !contractData.endDate) {\n      recommendations.push('Specify project completion date');\n    }\n    \n    // Calculate compliance score (0-100)\n    const totalChecks = Object.keys(cslbRequirements.requiredElements).length + 4; // +4 for additional validations\n    const passedChecks = totalChecks - requiredCheck.missing.length - (allWarnings.length * 0.5);\n    const complianceScore = Math.max(0, Math.min(100, Math.round((passedChecks / totalChecks) * 100)));\n    \n    const processingTime = Date.now() - startTime;\n    \n    return {\n      complianceStatus,\n      complianceScore,\n      isCompliant,\n      needsReview,\n      nonCompliant,\n      missingElements: requiredCheck.missing,\n      warnings: allWarnings,\n      recommendations,\n      processingTime: `${processingTime}ms`,\n      timestamp: new Date().toISOString(),\n      callSid: callSid,\n      \n      // Detailed breakdown\n      validationResults: {\n        requiredElements: requiredCheck,\n        paymentStructure: paymentWarnings,\n        projectScope: scopeWarnings,\n        timeline: timelineWarnings,\n        license: licenseWarnings\n      },\n      \n      // CSLB reference\n      cslbReference: {\n        section: '¬ß7159',\n        title: 'Home Improvement Contracts',\n        url: 'https://www.leginfo.legislature.ca.gov/faces/codes_displaySection.xhtml?sectionNum=7159.&lawCode=BPC'\n      }\n    };\n    \n  } catch (error) {\n    console.error('Error in compliance check:', error);\n    return {\n      complianceStatus: 'ERROR',\n      error: 'COMPLIANCE_CHECK_FAILED',\n      message: error.message,\n      timestamp: new Date().toISOString(),\n      callSid: callSid\n    };\n  }\n};\n\n// Execute compliance check\nreturn runComplianceCheck();"
      },
      "typeVersion": 1,
      "position": [240, 300],
      "id": "cslb-compliance-check"
    },
    {
      "name": "Build Scope Summary",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "// Function Node: Build Scope Summary\n// Input: $json.extractedData or $json (project data)\n// Output: Formatted scope summary and project details\n\nconst projectData = $json.extractedData || $json;\nconst callSid = projectData.callSid || $json.CallSid;\nconst complianceResults = $json.complianceResults || $json;\n\n// Scope summary builder\nconst buildScopeSummary = (data) => {\n  const parts = [];\n  \n  // Project type\n  if (data.project_type || data.projectType) {\n    const projectType = data.project_type || data.projectType;\n    parts.push(projectType.charAt(0).toUpperCase() + projectType.slice(1));\n  }\n  \n  // Location\n  if (data.project_address || data.projectAddress) {\n    const address = data.project_address || data.projectAddress;\n    parts.push(`at ${address}`);\n  }\n  \n  // Budget\n  if (data.budget) {\n    const budget = data.budget.startsWith('$') ? data.budget : `$${data.budget}`;\n    parts.push(`budget ${budget}`);\n  }\n  \n  // Timeline\n  if (data.start_date || data.startDate) {\n    const startDate = data.start_date || data.startDate;\n    parts.push(`starting ${startDate}`);\n  }\n  \n  // Materials\n  if (data.materials_by || data.materialsProvidedBy) {\n    const materials = data.materials_by || data.materialsProvidedBy;\n    parts.push(`materials by ${materials}`);\n  }\n  \n  return parts.length > 0 ? parts.join(', ') + '.' : 'Project details pending.';\n};\n\n// Generate detailed project summary\nconst generateDetailedSummary = (data) => {\n  const summary = {\n    projectType: data.project_type || data.projectType || 'Not specified',\n    address: data.project_address || data.projectAddress || 'Not provided',\n    scope: data.scope_of_work || data.scopeOfWork || 'Not provided',\n    budget: data.budget || 'Not specified',\n    paymentTerms: data.payment_terms || data.paymentTerms || 'Not specified',\n    startDate: data.start_date || data.startDate || 'Not specified',\n    endDate: data.end_date || data.endDate || 'Not specified',\n    materialsBy: data.materials_by || data.materialsProvidedBy || 'Not specified',\n    contactMethod: data.preferred_contact_method || data.preferredContactMethod || 'Not specified',\n    businessName: data.business_name || data.clientName || 'Not provided'\n  };\n  \n  // Format budget for display\n  if (summary.budget && !summary.budget.startsWith('$')) {\n    summary.budget = `$${summary.budget}`;\n  }\n  \n  // Format payment terms\n  if (summary.paymentTerms) {\n    summary.paymentTerms = summary.paymentTerms.replace(/(\\d+)%/g, '$1%');\n  }\n  \n  return summary;\n};\n\n// Generate SMS-friendly summary (160 char limit)\nconst generateSMSSummary = (data, complianceWarnings = []) => {\n  const parts = [];\n  \n  // Business name (truncated if needed)\n  const business = data.business_name || data.clientName || 'New Client';\n  parts.push(business.length > 20 ? business.substring(0, 17) + '...' : business);\n  \n  // Project type\n  const projectType = data.project_type || data.projectType || 'Project';\n  parts.push(projectType);\n  \n  // Address (truncated)\n  const address = data.project_address || data.projectAddress || 'Address pending';\n  parts.push(address.length > 30 ? address.substring(0, 27) + '...' : address);\n  \n  // Budget\n  const budget = data.budget || 'Budget pending';\n  parts.push(budget);\n  \n  // Contact method\n  const contact = data.preferred_contact_method || data.preferredContactMethod || 'Contact pending';\n  parts.push(contact);\n  \n  let smsText = parts.join('\\n');\n  \n  // Add compliance warnings if any\n  if (complianceWarnings.length > 0) {\n    smsText += '\\n‚ö†Ô∏è Review required';\n  }\n  \n  // Add call ID\n  smsText += `\\nID: ${callSid || 'N/A'}`;\n  \n  // Ensure we don't exceed 160 characters\n  if (smsText.length > 160) {\n    smsText = smsText.substring(0, 157) + '...';\n  }\n  \n  return smsText;\n};\n\n// Generate email summary\nconst generateEmailSummary = (data, complianceWarnings = []) => {\n  const summary = generateDetailedSummary(data);\n  \n  return `New Construction Contract Request\n\nCall Details:\n- Call ID: ${callSid || 'N/A'}\n- Timestamp: ${new Date().toLocaleString()}\n- Caller Phone: ${data.callerPhone || data.From || 'N/A'}\n\nBusiness Information:\n- Business Name: ${summary.businessName}\n- Contact Method: ${summary.contactMethod}\n- Returning Customer: ${data.isReturningCaller || data.is_Repeat ? 'Yes' : 'No'}\n\nProject Details:\n- Project Type: ${summary.projectType}\n- Address: ${summary.address}\n- Scope: ${summary.scope}\n- Budget: ${summary.budget}\n- Payment Terms: ${summary.paymentTerms}\n- Materials By: ${summary.materialsBy}\n- Start Date: ${summary.startDate}\n- End Date: ${summary.endDate}\n\nScope Summary:\n${buildScopeSummary(data)}\n\n${complianceWarnings.length > 0 ? \n`Compliance Warnings:\n${complianceWarnings.join('\\n')}\n\n` : ''}Next Steps:\n1. Review project details\n2. Generate contract document\n3. Send to customer via ${summary.contactMethod}\n4. Follow up within 24 hours`;\n};\n\n// Generate contract summary for document generation\nconst generateContractSummary = (data) => {\n  const summary = generateDetailedSummary(data);\n  \n  return {\n    projectOverview: buildScopeSummary(data),\n    detailedScope: summary.scope,\n    financialSummary: {\n      budget: summary.budget,\n      paymentTerms: summary.paymentTerms\n    },\n    timeline: {\n      startDate: summary.startDate,\n      endDate: summary.endDate\n    },\n    materials: summary.materialsBy,\n    contactInfo: {\n      businessName: summary.businessName,\n      contactMethod: summary.contactMethod\n    }\n  };\n};\n\n// Generate notification payload\nconst generateNotificationPayload = (data, complianceWarnings = []) => {\n  const summary = generateDetailedSummary(data);\n  \n  return {\n    callSid: callSid,\n    timestamp: new Date().toISOString(),\n    caller: {\n      phone: data.callerPhone || data.From,\n      business: summary.businessName,\n      contactMethod: summary.contactMethod,\n      isReturning: data.isReturningCaller || data.is_Repeat\n    },\n    project: {\n      type: summary.projectType,\n      address: summary.address,\n      scope: summary.scope,\n      budget: summary.budget,\n      paymentTerms: summary.paymentTerms,\n      materialsBy: summary.materialsBy,\n      startDate: summary.startDate,\n      endDate: summary.endDate\n    },\n    compliance: {\n      warnings: complianceWarnings,\n      licenseNumber: data.license_number || data.licenseNumber\n    },\n    scopeSummary: buildScopeSummary(data)\n  };\n};\n\n// Main function\nconst buildScopeSummaryData = () => {\n  try {\n    const scopeSummary = buildScopeSummary(projectData);\n    const detailedSummary = generateDetailedSummary(projectData);\n    const complianceWarnings = complianceResults?.warnings || [];\n    const smsSummary = generateSMSSummary(projectData, complianceWarnings);\n    const emailSummary = generateEmailSummary(projectData, complianceWarnings);\n    const contractSummary = generateContractSummary(projectData);\n    const notificationPayload = generateNotificationPayload(projectData, complianceWarnings);\n    \n    return {\n      scopeSummary,\n      detailedSummary,\n      smsSummary,\n      emailSummary,\n      contractSummary,\n      notificationPayload,\n      complianceResults,\n      timestamp: new Date().toISOString(),\n      callSid: callSid,\n      success: true\n    };\n    \n  } catch (error) {\n    console.error('Error building scope summary:', error);\n    return {\n      error: 'SCOPE_SUMMARY_ERROR',\n      message: error.message,\n      timestamp: new Date().toISOString(),\n      callSid: callSid,\n      success: false\n    };\n  }\n};\n\n// Execute and return results\nreturn buildScopeSummaryData();"
      },
      "typeVersion": 1,
      "position": [460, 300],
      "id": "build-scope-summary"
    }
  ],
  "connections": {
    "CSLB Compliance Check": {
      "main": [
        [
          {
            "node": "Build Scope Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "enhanced-orchestrator-part3",
  "tags": [
    {
      "createdAt": "2025-01-27T10:00:00.000Z",
      "updatedAt": "2025-01-27T10:00:00.000Z",
      "id": "voice-intake",
      "name": "Voice Intake"
    }
  ]
} 