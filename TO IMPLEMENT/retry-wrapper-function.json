{
  "name": "Retry Wrapper Workflow",
  "nodes": [
    {
      "name": "Retry Wrapper",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "// Function Node: Retry Wrapper\n// Input: $json (data to process), $json.retryConfig (optional retry settings)\n// Output: Result with retry metadata\n\nconst inputData = $json;\nconst retryConfig = $json.retryConfig || {};\n\n// Default retry configuration\nconst defaultConfig = {\n  maxAttempts: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 10000, // 10 seconds\n  backoffMultiplier: 2,\n  retryableErrors: [\n    'TIMEOUT',\n    'NETWORK_ERROR',\n    'RATE_LIMIT',\n    'SERVICE_UNAVAILABLE',\n    'INTERNAL_SERVER_ERROR'\n  ],\n  timeoutMs: 30000 // 30 seconds\n};\n\nconst config = { ...defaultConfig, ...retryConfig };\n\n// Exponential backoff calculator\nconst calculateDelay = (attempt) => {\n  const delay = config.baseDelay * Math.pow(config.backoffMultiplier, attempt - 1);\n  return Math.min(delay, config.maxDelay);\n};\n\n// Error classification\nconst classifyError = (error) => {\n  const errorMessage = error.message || error.toString();\n  const errorCode = error.code || error.status || '';\n  \n  // Network/connection errors\n  if (errorMessage.includes('network') || errorMessage.includes('connection') || errorMessage.includes('timeout')) {\n    return 'NETWORK_ERROR';\n  }\n  \n  // Rate limiting\n  if (errorCode === 429 || errorMessage.includes('rate limit') || errorMessage.includes('too many requests')) {\n    return 'RATE_LIMIT';\n  }\n  \n  // Server errors\n  if (errorCode >= 500 || errorMessage.includes('internal server error') || errorMessage.includes('service unavailable')) {\n    return 'SERVICE_UNAVAILABLE';\n  }\n  \n  // Timeout errors\n  if (errorMessage.includes('timeout') || errorCode === 'TIMEOUT') {\n    return 'TIMEOUT';\n  }\n  \n  // Client errors (usually not retryable)\n  if (errorCode >= 400 && errorCode < 500) {\n    return 'CLIENT_ERROR';\n  }\n  \n  return 'UNKNOWN_ERROR';\n};\n\n// Retry wrapper for async operations\nconst retryWrapper = async (operation, operationName = 'operation') => {\n  let lastError;\n  const attempts = [];\n  const startTime = Date.now();\n  \n  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n    const attemptStartTime = Date.now();\n    \n    try {\n      // Execute the operation\n      const result = await operation();\n      \n      const attemptDuration = Date.now() - attemptStartTime;\n      const totalDuration = Date.now() - startTime;\n      \n      // Log successful attempt\n      attempts.push({\n        attempt,\n        status: 'SUCCESS',\n        duration: attemptDuration,\n        timestamp: new Date().toISOString()\n      });\n      \n      return {\n        success: true,\n        result,\n        attempts,\n        totalAttempts: attempt,\n        totalDuration: `${totalDuration}ms`,\n        timestamp: new Date().toISOString()\n      };\n      \n    } catch (error) {\n      const attemptDuration = Date.now() - attemptStartTime;\n      const errorType = classifyError(error);\n      \n      // Log failed attempt\n      attempts.push({\n        attempt,\n        status: 'FAILED',\n        error: errorType,\n        errorMessage: error.message,\n        duration: attemptDuration,\n        timestamp: new Date().toISOString()\n      });\n      \n      lastError = error;\n      \n      // Check if error is retryable\n      if (!config.retryableErrors.includes(errorType)) {\n        console.log(`${operationName}: Non-retryable error (${errorType}), stopping retries`);\n        break;\n      }\n      \n      // Check if we have more attempts\n      if (attempt < config.maxAttempts) {\n        const delay = calculateDelay(attempt);\n        console.log(`${operationName}: Attempt ${attempt} failed (${errorType}), retrying in ${delay}ms...`);\n        \n        // Wait before next attempt\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  // All attempts failed\n  const totalDuration = Date.now() - startTime;\n  \n  console.error(`${operationName}: All ${config.maxAttempts} attempts failed`);\n  \n  return {\n    success: false,\n    error: lastError,\n    errorType: classifyError(lastError),\n    attempts,\n    totalAttempts: config.maxAttempts,\n    totalDuration: `${totalDuration}ms`,\n    timestamp: new Date().toISOString()\n  };\n};\n\n// Specific retry wrappers for common operations\n\n// OpenAI API retry wrapper\nconst retryOpenAI = async (openAICall) => {\n  const openAIConfig = {\n    ...config,\n    retryableErrors: [\n      'RATE_LIMIT',\n      'SERVICE_UNAVAILABLE',\n      'TIMEOUT',\n      'NETWORK_ERROR'\n    ],\n    maxAttempts: 3,\n    baseDelay: 2000 // Longer delay for OpenAI\n  };\n  \n  return retryWrapper(openAICall, 'OpenAI API Call');\n};\n\n// Google Sheets API retry wrapper\nconst retryGoogleSheets = async (sheetsCall) => {\n  const sheetsConfig = {\n    ...config,\n    retryableErrors: [\n      'RATE_LIMIT',\n      'SERVICE_UNAVAILABLE',\n      'TIMEOUT',\n      'NETWORK_ERROR'\n    ],\n    maxAttempts: 3,\n    baseDelay: 1000\n  };\n  \n  return retryWrapper(sheetsCall, 'Google Sheets API Call');\n};\n\n// Twilio API retry wrapper\nconst retryTwilio = async (twilioCall) => {\n  const twilioConfig = {\n    ...config,\n    retryableErrors: [\n      'RATE_LIMIT',\n      'SERVICE_UNAVAILABLE',\n      'TIMEOUT',\n      'NETWORK_ERROR'\n    ],\n    maxAttempts: 2, // Fewer retries for Twilio\n    baseDelay: 1000\n  };\n  \n  return retryWrapper(twilioCall, 'Twilio API Call');\n};\n\n// HTTP request retry wrapper\nconst retryHTTPRequest = async (httpCall) => {\n  const httpConfig = {\n    ...config,\n    retryableErrors: [\n      'RATE_LIMIT',\n      'SERVICE_UNAVAILABLE',\n      'TIMEOUT',\n      'NETWORK_ERROR',\n      'INTERNAL_SERVER_ERROR'\n    ],\n    maxAttempts: 3,\n    baseDelay: 1000\n  };\n  \n  return retryWrapper(httpCall, 'HTTP Request');\n};\n\n// Main function - determine which retry wrapper to use\nconst executeWithRetry = () => {\n  const operationType = inputData.operationType || 'generic';\n  const operation = inputData.operation;\n  \n  if (!operation) {\n    return {\n      error: 'MISSING_OPERATION',\n      message: 'No operation provided for retry wrapper',\n      timestamp: new Date().toISOString()\n    };\n  }\n  \n  // Return the appropriate retry wrapper based on operation type\n  switch (operationType.toLowerCase()) {\n    case 'openai':\n      return {\n        retryFunction: retryOpenAI,\n        config: {\n          ...config,\n          retryableErrors: ['RATE_LIMIT', 'SERVICE_UNAVAILABLE', 'TIMEOUT', 'NETWORK_ERROR'],\n          maxAttempts: 3,\n          baseDelay: 2000\n        },\n        operationType: 'openai',\n        timestamp: new Date().toISOString()\n      };\n      \n    case 'googlesheets':\n    case 'sheets':\n      return {\n        retryFunction: retryGoogleSheets,\n        config: {\n          ...config,\n          retryableErrors: ['RATE_LIMIT', 'SERVICE_UNAVAILABLE', 'TIMEOUT', 'NETWORK_ERROR'],\n          maxAttempts: 3,\n          baseDelay: 1000\n        },\n        operationType: 'googlesheets',\n        timestamp: new Date().toISOString()\n      };\n      \n    case 'twilio':\n      return {\n        retryFunction: retryTwilio,\n        config: {\n          ...config,\n          retryableErrors: ['RATE_LIMIT', 'SERVICE_UNAVAILABLE', 'TIMEOUT', 'NETWORK_ERROR'],\n          maxAttempts: 2,\n          baseDelay: 1000\n        },\n        operationType: 'twilio',\n        timestamp: new Date().toISOString()\n      };\n      \n    case 'http':\n    case 'httprequest':\n      return {\n        retryFunction: retryHTTPRequest,\n        config: {\n          ...config,\n          retryableErrors: ['RATE_LIMIT', 'SERVICE_UNAVAILABLE', 'TIMEOUT', 'NETWORK_ERROR', 'INTERNAL_SERVER_ERROR'],\n          maxAttempts: 3,\n          baseDelay: 1000\n        },\n        operationType: 'http',\n        timestamp: new Date().toISOString()\n      };\n      \n    default:\n      return {\n        retryFunction: retryWrapper,\n        config: config,\n        operationType: 'generic',\n        timestamp: new Date().toISOString()\n      };\n  }\n};\n\n// Usage examples and documentation\nconst usageExamples = {\n  openai: `\n// Example: Retry OpenAI API call\nconst result = await retryOpenAI(async () => {\n  return await openai.chat.completions.create({\n    model: 'gpt-3.5-turbo',\n    messages: [{ role: 'user', content: 'Hello' }]\n  });\n});\n  `,\n  \n  googlesheets: `\n// Example: Retry Google Sheets API call\nconst result = await retryGoogleSheets(async () => {\n  return await sheets.spreadsheets.values.append({\n    spreadsheetId: 'your-sheet-id',\n    range: 'Sheet1!A:Z',\n    valueInputOption: 'RAW',\n    resource: { values: [['data']] }\n  });\n});\n  `,\n  \n  twilio: `\n// Example: Retry Twilio API call\nconst result = await retryTwilio(async () => {\n  return await twilio.messages.create({\n    body: 'Hello',\n    from: '+1234567890',\n    to: '+0987654321'\n  });\n});\n  `\n};\n\n// Return retry wrapper configuration and examples\nreturn {\n  ...executeWithRetry(),\n  usageExamples,\n  documentation: {\n    description: 'Retry wrapper for API calls with exponential backoff',\n    configOptions: config,\n    supportedOperations: ['openai', 'googlesheets', 'twilio', 'http', 'generic'],\n    retryableErrors: config.retryableErrors\n  }\n};"
      },
      "typeVersion": 1,
      "position": [500, 300],
      "id": "retry-wrapper-function"
    }
  ],
  "connections": {},
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "retry-wrapper-workflow",
  "tags": [
    {
      "createdAt": "2025-01-27T10:00:00.000Z",
      "updatedAt": "2025-01-27T10:00:00.000Z",
      "id": "retry-wrapper",
      "name": "Retry Wrapper"
    }
  ]
} 